#include "RealSensePluginPrivatePCH.h"
#include "RemoteFrameSource.h"
#define SNAPPY_STATIC 1
#include "snappy-c.h"
DEFINE_LOG_CATEGORY_STATIC(LogRemoteFrameSource, Log, All);
using namespace easywsclient;
static void DecompressWithSnappy(const uint8 *Input, int32 Size, TArray<uint8> &UncompressedBinaryArray)
{
	// Given data in "compressed[0..compressed_length-1]" generated by
	// calling the Snappy::Compress routine, this routine
	// stores the uncompressed data to
	//    uncompressed[0..GetUncompressedLength(compressed)-1]
	// returns false if the message is corrupted and could not be decrypted
	//bool RawUncompress(const char* compressed, size_t compressed_length,
	//char* uncompressed);

	size_t Length;
	/*
	if (snappy::GetUncompressedLength((const char *)Input, (size_t)Size, &Length))
	{
	UncompressedBinaryArray.SetNumUninitialized(Length);
	if (snappy::RawUncompress((const char *)Input, (size_t)Size, (char*)UncompressedBinaryArray.GetData()))
	{
	return;
	}
	}
	*/
	if (snappy_uncompressed_length((const char *)Input, Size, &Length) == snappy_status::SNAPPY_OK)
	{
		UncompressedBinaryArray.SetNumUninitialized(Length);
		if (snappy_uncompress((const char *)Input, (size_t)Size, (char*)UncompressedBinaryArray.GetData(), &Length) == SNAPPY_OK)
		{
			return;
		}
	}
	UE_LOG(LogRemoteFrameSource, Error, TEXT("Decompression failed"));
}

static void CompressWithSnappy(const uint8 *Input, int32 Size, std::vector<uint8> &CompressedBinaryArray)
{
	// Example:
	//    char* output = new char[snappy::MaxCompressedLength(input_length)];
	//    size_t output_length;
	//    RawCompress(input, input_length, output, &output_length);
	//    ... Process(output, output_length) ...
	//    delete [] output;
	//void RawCompress(const char* input,
	//	size_t input_length,
	//	char* compressed,
	//	size_t* compressed_length);

	size_t Length;
	/*
	CompressedBinaryArray.resize(snappy::MaxCompressedLength(Size));
	snappy::RawCompress((const char *)Input, Size, (char*)CompressedBinaryArray.data(), &Length);
	CompressedBinaryArray.resize(Length);
	*/

	CompressedBinaryArray.resize(snappy_max_compressed_length(Size));
	if (snappy_compress((const char *)Input, Size, (char*)CompressedBinaryArray.data(), &Length) == snappy_status::SNAPPY_OK)
	{
		CompressedBinaryArray.resize(Length);
		return;
	}
	UE_LOG(LogRemoteFrameSource, Error, TEXT("Compression failed"));
}

static void Compress(const uint8 *Input, int32 Size, std::vector<uint8> &CompressedBinaryArray)
{
	CompressWithSnappy(Input, Size, CompressedBinaryArray);
}

static void Decompress(const uint8 *Input, int32 Size, TArray<uint8> &UncompressedBinaryArray)
{
	DecompressWithSnappy(Input, Size, UncompressedBinaryArray);
}

class FDataOutput
{
	std::vector<uint8> Buffer;
	std::vector<uint8> Uncompressed;
	std::vector<uint8> Compressed;
	std::vector<uint8> *CurrentBuffer;
	bool bCompressMeshData;
public:

	FDataOutput() : bCompressMeshData(true)
	{

	}

	void Reset()
	{
		Buffer.clear();
		CurrentBuffer = &Buffer;
	}

	void BeginFrame()
	{
		WriteInt(0); // will hold the length of this frame
	}

	std::vector<uint8> &EndFrame()
	{
		*((int32*)Buffer.data()) = Buffer.size() - 4;
		return Buffer;
	}

	void WriteColors1(const TArray<FColor> &Colors)
	{

		WriteInt(Colors.Num() / 4);
		if (Colors.Num() > 0)
		{
			for (int i = 0; i < Colors.Num(); i += 4)
			{
				FVector Avg(0, 0, 0);
				for (int j = 0; j < 4; j++)
				{
					Avg.X += (Colors[i + j].R);
					Avg.Y += (Colors[i + j].G);
					Avg.Z += (Colors[i + j].B);
				}
				Avg /= 4;
				FColor C(FMath::RoundToInt(Avg.X), FMath::RoundToInt(Avg.Y), FMath::RoundToInt(Avg.Z), 1);
				WriteColor(Colors[i]);
			}
		}
	}


	void WriteVertexData(const TArray<FVector> &Vertices, const TArray<FColor> &Colors)
	{
		const bool bCompress = Vertices.Num() > 0 && this->bCompressMeshData;
		WriteBool(bCompress);
		if (bCompress)
		{
			Uncompressed.clear();
			CurrentBuffer = &Uncompressed;
			WriteVertices(Vertices);
			WriteColors1(Colors);
			Compress(Uncompressed.data(), Uncompressed.size(), Compressed);
			CurrentBuffer = &Buffer;
			WriteInt((int32)Compressed.size());
			Write(Compressed.data(), (int32)Compressed.size());
		}
		else
		{
			WriteVertices(Vertices);
			WriteColors1(Colors);
		}
	}

	void WriteVertices(const TArray<FVector> &Vertices)
	{
		WriteInt(Vertices.Num());
		if (Vertices.Num() > 0)
		{
			for (int i = 0; i < Vertices.Num(); i++) {
				const FVector &V = Vertices[i];
				WritePos(V.X);
				WritePos(V.Y);
				WritePos(V.Z);
			}

		}
	}


	void WriteColor(FColor C)
	{
		if (false)
		{
			uint8 rgb[3];
			rgb[0] = C.R;
			rgb[1] = C.G;
			rgb[2] = C.B;
			Write(rgb, 3);
		}
		else
		{
			WriteUShort((uint16)((C.R & 0xF8) << 8) | ((C.G & 0xFC) << 3) | (C.B >> 3));
		}
	}

	void WriteColors(const TArray<FColor> &Colors)
	{
		WriteInt(Colors.Num());
		if (Colors.Num() > 0)
		{
			for (int i = 0; i < Colors.Num(); i++)
			{
				WriteColor(Colors[i]);
			}
		}
	}

	void WritePos(float Value)
	{
		int16 Target = int16(Value * 10.0f); // cm to mm
		WriteShort(Target);
	}

	void WriteShort(int16 Value)
	{
		Write(&Value, sizeof(Value));
	}

	void WriteUShort(uint16 Value)
	{
		Write(&Value, sizeof(Value));
	}

	void WriteInt(int32 Value)
	{
		Write(&Value, sizeof(Value));
	}

	void WriteBool(bool Value)
	{
		uint8 Byte = Value ? 1 : 0;
		Write(&Byte, 1);
	}

	void WriteFloat(float Value)
	{
		Write(&Value, sizeof(Value));
	}

	void Write(const void *Value, int32 Size)
	{
		if (Size > 0)
		{
			const uint8 *Begin = (const uint8*)Value;
			CurrentBuffer->insert(CurrentBuffer->end(), Begin, Begin + Size);
		}
	}
};


class FDataInput
{
public:
	void Reset(void *Data, int32 Size)
	{
		Frame = (uint8*)Data;
		FramePtr = 0;
		CurrentFrameSize = Size;
	}
	int32 ReadInt()
	{
		int32 Result = *(int32*)GetCurrent();
		Advance(sizeof(int32));
		return Result;
	}

	bool ReadBool()
	{
		bool Result = *(bool*)GetCurrent();
		Advance(sizeof(bool));
		return Result;
	}

	void ReadVertexData(TArray<FVector> &Vertices, TArray<FColor> &VertexColors)
	{
		bool bCompressed = ReadBool();
		if (bCompressed)
		{
			int32 BufferLength = ReadInt();
			uint8 *OrigFrame = Frame;
			int32 Ptr = FramePtr;
			int32 Size = CurrentFrameSize;
			const uint8 *Data = (const uint8*)GetCurrent();
			Buffer.Reset();
			Decompress(Data, BufferLength, Buffer);
			FramePtr = 0;
			Frame = Buffer.GetData();
			CurrentFrameSize = Buffer.Num();
			ReadVertices(Vertices);
			ReadColors1(VertexColors);
			Frame = OrigFrame;
			FramePtr = Ptr;
			CurrentFrameSize = Size;
			Advance(BufferLength);
		}
		else
		{
			ReadVertices(Vertices);
			ReadColors1(VertexColors);
		}
	}

	void ReadVertices(TArray<FVector> &Result)
	{
		const int32 VertexCount = ReadInt();
		Result.Reset(VertexCount);
		if (VertexCount > 0)
		{
			for (int32 i = 0; i < VertexCount; i++)
			{
				float X = ReadPos();
				float Y = ReadPos();
				float Z = ReadPos();
				Result.Add(FVector(X, Y, Z));
			}
		}
	}

	uint8 ReadByte()
	{
		uint8 Result = *(uint8*)GetCurrent();
		Advance(1);
		return Result;
	}

	FColor ReadColor()
	{
		if (false)
		{
			uint8 R = ReadByte();
			uint8 G = ReadByte();
			uint8 B = ReadByte();
			return FColor(R, G, B);
		}
		else
		{
			uint16 rgb = ReadUShort();
			return FColor(
				(rgb >> 8) & 0xF8,
				(rgb >> 3) & 0xFC,
				(rgb << 3) & 0xF8);
		}
	}

	void ReadColors1(TArray<FColor> &Result)
	{
		int32 Count = ReadInt();
		Result.Reset(Count);
		for (int i = 0; i < Count; i++)
		{
			FColor C = ReadColor();
			Result.Add(C);
			Result.Add(C);
			Result.Add(C);
			Result.Add(C);
		}
	}


	void ReadColors(TArray<FColor> &Result)
	{
		int32 Count = ReadInt();
		Result.Reset(Count);
		for (int i = 0; i < Count; i++)
		{
			Result.Add(ReadColor());
		}
	}

	float ReadPos()
	{
		int16 Value = ReadShort();
		return Value / 10.0f; // mm to cm
	}

	uint16 ReadUShort()
	{
		uint16 Result = *(uint16*)GetCurrent();
		Advance(sizeof(uint16));
		return Result;
	}

	int16 ReadShort()
	{
		int16 Result = *(int16*)GetCurrent();
		Advance(sizeof(int16));
		return Result;
	}

	float ReadFloat()
	{
		float Result = *(float*)GetCurrent();
		Advance(sizeof(float));
		return Result;
	}

	void Advance(int32 Count)
	{
		FramePtr += Count;
	}

	void *GetCurrent()
	{
		return FramePtr < CurrentFrameSize ? &Frame[FramePtr] : nullptr;
	}


	TArray<uint8> Buffer;
	uint8 *Frame;
	int32 FramePtr;
	int32 CurrentFrameSize;
};

static
WebSocket::pointer
Connect(const FString &ServerHost, int32 ServerPort, const FString &ServerUrl)
{
	FString Url = TEXT("ws://") + ServerHost + TEXT(":") + FString::FromInt(ServerPort) + ServerUrl;
	return WebSocket::from_url(TCHAR_TO_UTF8(*Url));
}

FRemoteFrameSource::FRemoteFrameSource(
	const FString &InServerHost, 
	int32 InServerPort, 
	const FString &InServerUrl, 
	const FString &InUserId, 
	const FString &InRemoteId):
	Callback(this)
	, Sock(nullptr)
	, ServerHost(InServerHost)
	, ServerPort(InServerPort)
	, ServerUrl(InServerUrl)
	, UserId(InUserId)
	, RemoteId(InRemoteId)
	, ReceivedFrame(0)
{
	DataInput = new FDataInput();
	DataOutput = new FDataOutput();
}

FRemoteFrameSource::~FRemoteFrameSource()
{
	delete DataInput;
	delete DataOutput;
}

void FRemoteFrameSource::SendFrameData(const TArray<int32> &Triangles,
	const TArray<FVector> &Vertices,
	const TArray<FColor> &VertexColors,
	const TSharedPtr<TArray<uint8>, ESPMode::ThreadSafe> &ColorBgra,
	int32 ColorWidth,
	int32 ColorHeight,
	const TArray<uint8> &AudioData,
	int32 Channels,
	int32 SampleRate)
{
	if (Triangles.Num() == 0 && AudioData.Num() == 0) return;
	if (!IsConnected())
	{
		Tick();
		return;
	}	
	if (Sock->getSendBacklog() > 0)
	{
		return;
	}
	DataOutput->Reset();
	DataOutput->BeginFrame();
	DataOutput->WriteVertexData(Vertices, VertexColors);
	DataOutput->WriteInt(0); // ColorWidth
	DataOutput->WriteInt(0); // ColorHeight
	DataOutput->WriteInt(AudioData.Num() / 2);
	DataOutput->Write(AudioData.GetData(), AudioData.Num());
	DataOutput->WriteInt(Channels);
	DataOutput->WriteInt(SampleRate);
	std::vector<uint8> & Result = DataOutput->EndFrame();
	Sock->sendBinary(Result);
}

int64 FRemoteFrameSource::GetFrameData(
	int64 LastFrame,
	TArray<int32> &Triangles,
	TArray<FVector> &Vertices,
	TArray<FColor> &VertexColors,
	TSharedPtr<TArray<uint8>, ESPMode::ThreadSafe> &ColorBgra,
	int32 &ColorWidth,
	int32 &ColorHeight,
	TArray<uint8> &AudioData,
	int32 &Channels,
	int32 &SampleRate)
{
	int64 Result = LastFrame;
	Crit.Lock();
	if (LastFrame < ReceivedFrame)
	{
		Vertices = this->Vertices;
		VertexColors = this->VertexColors;
		Triangles.Reset();
		for (int Next = 0; Next < Vertices.Num(); Next += 4)
		{
			Triangles.Add(Next + 0);
			Triangles.Add(Next + 1);
			Triangles.Add(Next + 2);

			Triangles.Add(Next + 1);
			Triangles.Add(Next + 3);
			Triangles.Add(Next + 2);
		}
		if (ColorBgra.IsValid())
		{
			ColorBgra->Reset();
		}
		ColorWidth = 0;
		ColorHeight = 0;
		AudioData.Reset();
		if (this->AudioData.Num() > 0)
		{
			AudioData.Append((const uint8*)this->AudioData.GetData(), this->AudioData.Num() * 2);
		}
		Channels = this->Channels;
		SampleRate = this->SampleRate;
		Result = ReceivedFrame;
	}
	Crit.Unlock();
	Tick();
	return Result;
}

void FRemoteFrameSource::HandleWSData(void *Data, int32 Size)
{
	DataInput->Reset(Data, Size);
	int32 FrameSize = DataInput->ReadInt();
	Crit.Lock();
	DataInput->ReadVertexData(Vertices, VertexColors);
	int32 ColorWidth = DataInput->ReadInt();
	int32 ColorHeight = DataInput->ReadInt();
	// @TODO Read color buffer if present
	int32 SampleCount = DataInput->ReadInt();
	AudioData.Reset();
	for (int32 i = 0; i < SampleCount; i++) 
	{
		AudioData.Add(DataInput->ReadShort());
	}
	Channels = DataInput->ReadInt();
	SampleRate = DataInput->ReadInt();
	ReceivedFrame++;
	Crit.Unlock();
}

void FRemoteFrameSource::Tick()
{
	if (Sock == nullptr)
	{
		Sock = Connect(ServerHost, ServerPort, ServerUrl + TEXT("?userId=") + UserId + TEXT("&source=") + RemoteId);
	}
	if (Sock)
	{
		Sock->poll();
		Sock->dispatchBinary(Callback);
	}
}

void FRemoteFrameSource::Close()
{
	if (Sock) {
		Sock->close(true);
	}
}
bool FRemoteFrameSource::IsConnected()
{
	return Sock != nullptr && Sock->getReadyState() == WebSocket::OPEN;
}

